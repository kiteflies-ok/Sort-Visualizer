<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sorting Algorithm Visualizer</title>
  <style>
    body {
      font-family: "Times New Roman", Times, serif;
      margin: 20px;
      background-color: #0e0414;
    }

    #container {
      display: flex;
      gap: 20px;
      margin-top: 50px;
    }

    .logo-container {
      position: fixed;
      border-radius: 15px;
      top: 20px;
      right: 20px;
      z-index: 1000;
      transition: transform 0.3s ease;
    }

    .animated-logo {
      width: 170px;
      height: auto;
      border-radius: 80px;
      animation: bounce 3s infinite;
    }

    .logo-container:hover {
      transform: scale(1.1);
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .animated-heading {
      font-size: 3.5rem;
      text-align: center;
      background: linear-gradient(45deg, #e7e41e, #ec0063, #e41010);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: float 3s ease-in-out infinite;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      font-family: "Times New Roman", Times, serif;
      transition: transform 0.3s ease;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .animated-heading:hover {
      transform: scale(1.05);
      cursor: pointer;
    }

    #visualization {
      flex: 2;
      background: rgb(243, 242, 161);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    #algorithm-explanation {
      font-size: 1.2rem;
      text-align: center;
      color: #000;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      width: 100%;
    }

    #code-panel {
      flex: 1;
      background: #423899;
      color: #b8c5dd;
      padding: 15px;
      border-radius: 8px;
      overflow: auto;
      max-height: 400px;
    }

    .array-element {
      display: inline-block;
      background: #e22684;
      margin: 2px;
      font-size: 16px;
      padding: 10px;
      color: rgb(223, 213, 84);
      transition: all 0.3s;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    button {
      padding: 1em 2em;
      background: linear-gradient(45deg, #ff8432, #e100ff, #22d8cc);
      border: none;
      color: rgb(251, 255, 15);
      font-weight: bold;
      font-size: 25px;
      border-radius: 1000px;
      font-family: "Gill Sans", sans-serif;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    button:hover {
      z-index: 0;
      box-shadow: 40px 0 100px;
      background: linear-gradient(45deg, #ff8432, #e100ff, #22d8cc);
    }

    select {
      padding: 16px 32px;
      font-size: 25px;
      border: 4px solid #2b2525;
      color: rgb(255, 238, 0);
      font-weight: bold;
      font-family: monospace;
      background: linear-gradient(45deg, #ff8432, #e100ff, #22d8cc);
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 4px;
    }

    select:hover {
      background: linear-gradient(45deg, #d9f827, #45b7d1);
      border-color: #45b7d1;
      color: rgb(0, 115, 209);
      box-shadow: 0 4px 15px rgba(79, 192, 210, 0.3);
    }

    #explanation {
      margin-top: 20px;
      font-size: 1.5rem;
      text-align: center;
      color: #000;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

   /* .active-line {
      background-color: rgba(255, 255, 255, 0.2);
      font-weight: bold;
    } */
  </style>
</head>
<body>
    
  <a href="/" class="logo-container">
    <img src="ravenclaw.png" alt="Website Logo" class="animated-logo" />
  </a>

  <h1 class="animated-heading">Sorting Algorithm Visualizer</h1>

  <div class="controls">
    <select id="algorithm-select" onchange="updateAlgorithmExplanation()">
      <option value="bubble">Bubble Sort</option>
      <option value="insertion">Insertion Sort</option>
      <option value="selection">Selection Sort</option>
      <option value="merge">Merge Sort</option>
      <option value="quick">Quick Sort</option>
      <option value="heap">Heap Sort</option>
      <option value="radix">Radix Sort</option>
    </select>

    <button onclick="startSorting()">Start Magic! ‚ú®</button>
    <button onclick="pauseResume()">Pause/Resume Magic üîÄ</button>
    <button onclick="reset()">Reset</button>
    <button onclick="previousStep()">Previous ‚èÆÔ∏è</button>
    <button onclick="nextStep()">Next ‚è≠Ô∏è</button>
    <input type="range" id="speed" min="10" max="1000" value="300" onchange="updateSpeed()" />
  </div>

  <div id="container">
    <div id="visualization">
      <div id="algorithm-explanation"></div>
      <div id="array-visualization"></div>
    </div>
    <div id="code-panel"></div>
  </div>

  <div id="explanation"></div>

    <script>
        let array = [];
        let isSorting = false;
        let isPaused = false;
        let delay = 300;
        let currentStepGenerator = null;
        let sortingSteps = [];
        let currentStepIndex = 0;
        let explanationText = "";

        function initializeArray() {
            array = Array.from({ length: 10 }, () => Math.floor(Math.random() * 50) + 10);
            sortingSteps = [[...array]];
            currentStepIndex = 0;
            explanationText = "Array initialized with random values.";
            visualizeArray();
            updateExplanation(explanationText);
            updateAlgorithmExplanation();
        }

        function visualizeArray() {
            const container = document.getElementById('array-visualization');
            container.innerHTML = '';
            array.forEach((value, index) => {
                const element = document.createElement('div');
                element.className = 'array-element';
                element.style.height = `${value * 4}px`;
                element.textContent = value;
                container.appendChild(element);
            });
        }

        function updateExplanation(text) {
            const explanationDiv = document.getElementById('explanation');
            explanationDiv.textContent = text;
        }

        function updateAlgorithmExplanation() {
            const algorithm = document.getElementById('algorithm-select').value;
            const explanationDiv = document.getElementById('algorithm-explanation');
            let explanation = '';

            switch (algorithm) {
                case 'bubble':
                    explanation = "Bubble Sort works by repeatedly swapping adjacent elements if they are in the wrong order. This process is repeated until the array is sorted.";
                    break;
                case 'insertion':
                    explanation = "Insertion Sort builds the final sorted array one element at a time. It takes each element and inserts it into its correct position in the sorted part of the array.";
                    break;
                case 'selection':
                    explanation = "Selection Sort works by repeatedly finding the minimum element from the unsorted part of the array and swapping it with the first unsorted element.";
                    break;
                case 'merge':
                    explanation = "Merge Sort divides the array into two halves, recursively sorts them, and then merges the two sorted halves.";
                    break;
                case 'quick':
                    explanation = "Quick Sort selects a pivot element and partitions the array into two halves such that elements less than the pivot are on the left and elements greater than the pivot are on the right. This process is repeated recursively.";
                    break;
                case 'heap':
                    explanation = "Heap Sort builds a max-heap from the array and repeatedly extracts the maximum element from the heap and places it at the end of the array.";
                    break;
                case 'radix':
                    explanation = "Radix Sort processes the digits of the numbers. It sorts the numbers digit by digit, starting from the least significant digit to the most significant digit.";
                    break;
            }

            explanationDiv.textContent = explanation;
            highlightCode(-1);
        }

        function previousStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                array = [...sortingSteps[currentStepIndex]];
                visualizeArray();
                updateExplanation(`Step ${currentStepIndex + 1}: ${explanationText}`);
            }
        }

        function nextStep() {
            if (currentStepIndex < sortingSteps.length - 1) {
                currentStepIndex++;
                array = [...sortingSteps[currentStepIndex]];
                visualizeArray();
                updateExplanation(`Step ${currentStepIndex + 1}: ${explanationText}`);
            } else {
                generateNextStep();
            }
        }

        function generateNextStep() {
            const algorithm = document.getElementById('algorithm-select').value;
            switch (algorithm) {
                case 'bubble':
                    bubbleSortStep();
                    break;
                case 'insertion':
                    insertionSortStep();
                    break;
                case 'selection':
                    selectionSortStep();
                    break;
                case 'merge':
                    mergeSortStep();
                    break;
                case 'quick':
                    quickSortStep();
                    break;
                case 'heap':
                    heapSortStep();
                    break;
                case 'radix':
                    radixSortStep();
                    break;
            }
        }

        function reset() {
            isSorting = false;
            isPaused = false;
            currentStepGenerator = null;
            initializeArray();
        }

        function updateSpeed() {
            delay = 1000 - document.getElementById('speed').value;
        }

        function* bubbleSort() {
            let n = array.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    if (array[j] > array[j + 1]) {
                        explanationText = `Swapping ${array[j]} and ${array[j + 1]} since ${array[j]} > ${array[j + 1]}`;
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                        sortingSteps.push([...array]);
                        visualizeArray();
                        updateExplanation(explanationText);
                        highlightCode(3);
                        yield;
                    }
                }
            }
            updateExplanation("Sorting complete!");
        }

        function* insertionSort() {
            let n = array.length;
            for (let i = 1; i < n; i++) {
                let key = array[i];
                let j = i - 1;
                while (j >= 0 && array[j] > key) {
                    explanationText = `Shifting ${array[j]} to the right since ${array[j]} > ${key}`;
                    array[j + 1] = array[j];
                    j = j - 1;
                    sortingSteps.push([...array]);
                    visualizeArray();
                    updateExplanation(explanationText);
                    highlightCode(3);
                    yield;
                }
                array[j + 1] = key;
                explanationText = `Inserting ${key} in the correct position`;
                sortingSteps.push([...array]);
                visualizeArray();
                updateExplanation(explanationText);
                highlightCode(5);
                yield;
            }
            updateExplanation("Sorting complete!");
        }

        function* selectionSort() {
            let n = array.length;
            for (let i = 0; i < n - 1; i++) {
                let minIndex = i;
                for (let j = i + 1; j < n; j++) {
                    if (array[j] < array[minIndex]) {
                        minIndex = j;
                    }
                }
                if (minIndex !== i) {
                    explanationText = `Swapping ${array[i]} with ${array[minIndex]} since ${array[minIndex]} is the smallest`;
                    [array[i], array[minIndex]] = [array[minIndex], array[i]];
                    sortingSteps.push([...array]);
                    visualizeArray();
                    updateExplanation(explanationText);
                    highlightCode(5);
                    yield;
                }
            }
            updateExplanation("Sorting complete!");
        }

        function* mergeSort(start = 0, end = array.length - 1) {
            if (start < end) {
                let mid = Math.floor((start + end) / 2);
                yield* mergeSort(start, mid);
                yield* mergeSort(mid + 1, end);
                yield* merge(start, mid, end);
            }
        }

        function* merge(start, mid, end) {
            let temp = [];
            let i = start, j = mid + 1;
            while (i <= mid && j <= end) {
                if (array[i] <= array[j]) {
                    temp.push(array[i++]);
                } else {
                    temp.push(array[j++]);
                }
            }
            while (i <= mid) {
                temp.push(array[i++]);
            }
            while (j <= end) {
                temp.push(array[j++]);
            }
            for (let k = 0; k < temp.length; k++) {
                array[start + k] = temp[k];
                sortingSteps.push([...array]);
                visualizeArray();
                updateExplanation(`Merging elements at position ${start + k}`);
                highlightCode(5);
                yield;
            }
        }

        function* quickSort(start = 0, end = array.length - 1) {
            if (start < end) {
                let pivotIndex = yield* partition(start, end);
                yield* quickSort(start, pivotIndex - 1);
                yield* quickSort(pivotIndex + 1, end);
            }
        }

        function* partition(start, end) {
            let pivot = array[end];
            let i = start - 1;
            for (let j = start; j < end; j++) {
                if (array[j] < pivot) {
                    i++;
                    explanationText = `Swapping ${array[i]} and ${array[j]} since ${array[j]} < ${pivot}`;
                    [array[i], array[j]] = [array[j], array[i]];
                    sortingSteps.push([...array]);
                    visualizeArray();
                    updateExplanation(explanationText);
                    highlightCode(5);
                    yield;
                }
            }
            explanationText = `Placing pivot ${pivot} in the correct position`;
            [array[i + 1], array[end]] = [array[end], array[i + 1]];
            sortingSteps.push([...array]);
            visualizeArray();
            updateExplanation(explanationText);
            highlightCode(7);
            yield;
            return i + 1;
        }

        function* heapSort() {
            let n = array.length;
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                yield* heapify(n, i);
            }
            for (let i = n - 1; i > 0; i--) {
                explanationText = `Swapping ${array[0]} and ${array[i]} to place the largest element at the end`;
                [array[0], array[i]] = [array[i], array[0]];
                sortingSteps.push([...array]);
                visualizeArray();
                updateExplanation(explanationText);
                highlightCode(5);
                yield;
                yield* heapify(i, 0);
            }
            updateExplanation("Sorting complete!");
        }

        function* heapify(n, i) {
            let largest = i;
            let left = 2 * i + 1;
            let right = 2 * i + 2;
            if (left < n && array[left] > array[largest]) {
                largest = left;
            }
            if (right < n && array[right] > array[largest]) {
                largest = right;
            }
            if (largest !== i) {
                explanationText = `Swapping ${array[i]} and ${array[largest]} to maintain the heap property`;
                [array[i], array[largest]] = [array[largest], array[i]];
                sortingSteps.push([...array]);
                visualizeArray();
                updateExplanation(explanationText);
                highlightCode(5);
                yield;
                yield* heapify(n, largest);
            }
        }

        function* radixSort() {
            let max = Math.max(...array);
            for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
                yield* countingSort(exp);
            }
            updateExplanation("Sorting complete!");
        }

        function* countingSort(exp) {
            let n = array.length;
            let output = new Array(n);
            let count = new Array(10).fill(0);

            for (let i = 0; i < n; i++) {
                let digit = Math.floor(array[i] / exp) % 10;
                count[digit]++;
            }

            for (let i = 1; i < 10; i++) {
                count[i] += count[i - 1];
            }

            for (let i = n - 1; i >= 0; i--) {
                let digit = Math.floor(array[i] / exp) % 10;
                output[count[digit] - 1] = array[i];
                count[digit]--;
            }

            for (let i = 0; i < n; i++) {
                array[i] = output[i];
                sortingSteps.push([...array]);
                visualizeArray();
                updateExplanation(`Placing ${array[i]} in the correct bucket`);
                highlightCode(5);
                yield;
            }
        }

        async function startSorting() {
            if (isSorting) return;
            isSorting = true;

            const algorithm = document.getElementById('algorithm-select').value;
            switch (algorithm) {
                case 'bubble':
                    currentStepGenerator = bubbleSort();
                    break;
                case 'insertion':
                    currentStepGenerator = insertionSort();
                    break;
                case 'selection':
                    currentStepGenerator = selectionSort();
                    break;
                case 'merge':
                    currentStepGenerator = mergeSort();
                    break;
                case 'quick':
                    currentStepGenerator = quickSort();
                    break;
                case 'heap':
                    currentStepGenerator = heapSort();
                    break;
                case 'radix':
                    currentStepGenerator = radixSort();
                    break;
            }

            while (!isPaused && !currentStepGenerator.next().done) {
                await new Promise(resolve => setTimeout(resolve, delay));
                if (isPaused) break;
            }
            isSorting = false;
        }

        function pauseResume() {
            isPaused = !isPaused;
            if (!isPaused && currentStepGenerator) {
                startSorting();
            }
        }

        function highlightCode(lineNumber) {
            const codePanel = document.getElementById('code-panel');
            const algorithm = document.getElementById('algorithm-select').value;
            let code = '';
            codePanel.innerHTML = code.split('\n').map((line, index) =>
        `<div class="${index === lineNumber ? 'active-line' : ''}" id="code-line-${index}">${line}</div>`
    ).join('');

    if (lineNumber >= 0) {
        const lineElement = document.getElementById(`code-line-${lineNumber}`);
        if (lineElement) {
            lineElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }         
            switch (algorithm) {
                case 'bubble':
                    code = `function bubbleSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n-1; i++) {
    for (let j = 0; j < n-i-1; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }
}`;
                    break;
                case 'insertion':
                    code = `function insertionSort(arr) {
  let n = arr.length;
  for (let i = 1; i < n; i++) {
    let key = arr[i];
    let j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = key;
  }
}`;
                    break;
                case 'selection':
                    code = `function selectionSort(arr) {
  let n = arr.length;
  for (let i = 0; i < n-1; i++) {
    let minIndex = i;
    for (let j = i+1; j < n; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
}`;
                    break;
                case 'merge':
                    code = `function mergeSort(arr, start = 0, end = arr.length - 1) {
  if (start < end) {
    let mid = Math.floor((start + end) / 2);
    mergeSort(arr, start, mid);
    mergeSort(arr, mid + 1, end);
    merge(arr, start, mid, end);
  }
}

function merge(arr, start, mid, end) {
  let temp = [];
  let i = start, j = mid + 1;
  while (i <= mid && j <= end) {
    if (arr[i] <= arr[j]) {
      temp.push(arr[i++]);
    } else {
      temp.push(arr[j++]);
    }
  }
  while (i <= mid) {
    temp.push(arr[i++]);
  }
  while (j <= end) {
    temp.push(arr[j++]);
  }
  for (let k = 0; k < temp.length; k++) {
    arr[start + k] = temp[k];
  }
}`;
                    break;
                case 'quick':
                    code = `function quickSort(arr, start = 0, end = arr.length - 1) {
  if (start < end) {
    let pivotIndex = partition(arr, start, end);
    quickSort(arr, start, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, end);
  }
}

function partition(arr, start, end) {
  let pivot = arr[end];
  let i = start - 1;
  for (let j = start; j < end; j++) {
    if (arr[j] < pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  [arr[i + 1], arr[end]] = [arr[end], arr[i + 1]];
  return i + 1;
}`;
                    break;
                case 'heap':
                    code = `function heapSort(arr) {
  let n = arr.length;
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  for (let i = n - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }
}

function heapify(arr, n, i) {
  let largest = i;
  let left = 2 * i + 1;
  let right = 2 * i + 2;
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }
  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}`;
                    break;
                case 'radix':
                    code = `function radixSort(arr) {
  let max = Math.max(...arr);
  for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {
    countingSort(arr, exp);
  }
}

function countingSort(arr, exp) {
  let n = arr.length;
  let output = new Array(n);
  let count = new Array(10).fill(0);

  for (let i = 0; i < n; i++) {
    let digit = Math.floor(arr[i] / exp) % 10;
    count[digit]++;
  }

  for (let i = 1; i < 10; i++) {
    count[i] += count[i - 1];
  }

  for (let i = n - 1; i >= 0; i--) {
    let digit = Math.floor(arr[i] / exp) % 10;
    output[count[digit] - 1] = arr[i];
    count[digit]--;
  }

  for (let i = 0; i < n; i++) {
    arr[i] = output[i];
  }
}`;
                    break;
            }

            codePanel.innerHTML = code.split('\n').map((line, index) =>
                `<div class="${index === lineNumber ? 'active-line' : ''}">${line}</div>`
            ).join('');
        }

        initializeArray();
    </script>
</body>
</html>